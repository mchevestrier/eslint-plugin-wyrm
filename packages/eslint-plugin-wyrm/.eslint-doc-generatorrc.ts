import fs from 'node:fs/promises';
import path from 'node:path';

// eslint-disable-next-line n/no-missing-import
import type { GenerateOptions } from 'eslint-doc-generator';
import * as prettier from 'prettier';
import * as ts from 'typescript';

globalThis.__filename = import.meta.filename;

const config: GenerateOptions = {
  ignoreConfig: [
    'all',
    'recommendedTypeCheckedOnly',
    'strictOnly',
    'strictTypeCheckedOnly',
  ],
  configFormat: 'name',
  configEmoji: [
    ['recommended', 'üü©'],
    ['recommendedTypeChecked', '‚úÖ'],
    ['strict', 'üü™'],
    ['strictTypeChecked', '‚òëÔ∏è'],
  ],
  urlRuleDoc: (name: string) => {
    const url =
      'https://github.com/mchevestrier/eslint-plugin-wyrm/blob/master/packages/eslint-plugin-wyrm/docs/rules/';
    return `${url}${name}.md`;
  },
  postprocess: async (content, pathToFile) => {
    if (path.basename(path.dirname(pathToFile)) !== 'rules') {
      return formatWithPrettier(content, pathToFile);
    }

    const ruleName = path.parse(pathToFile).name;
    const examples = await generateExamplesForRule(ruleName);
    const description = await generateDescriptionForRule(ruleName);

    const endAutoGeneratedHeader = '<!-- end auto-generated rule header -->';
    const additionalContent = [description, examples]
      .join('\n\n')
      .concat('\n', endAutoGeneratedHeader);

    const fullContent = content.replace(endAutoGeneratedHeader, additionalContent);

    return formatWithPrettier(fullContent, pathToFile);
  },
};

export default config;

async function formatWithPrettier(content: string, pathToFile: string) {
  const prettierConfig = await prettier.resolveConfig(pathToFile);
  const formatted = await prettier.format(content, {
    ...prettierConfig,
    parser: 'markdown',
  });
  return formatted;
}

async function generateDescriptionForRule(ruleName: string): Promise<string> {
  const code = await fs.readFile(
    path.join(import.meta.dirname, `./lib/rules/${ruleName}.ts`),
    {
      encoding: 'utf8',
    },
  );

  const [range] = ts.getLeadingCommentRanges(code, 0) ?? [];
  if (!range) return '';

  const leadingComment = code.slice(range.pos, range.end);
  const txt = ts.getTextOfJSDocComment(leadingComment);
  if (!txt?.startsWith('/**')) return '';

  if (!txt.startsWith('/**\n * @fileoverview\n *\n ')) {
    const msg = `For rule ${ruleName}, you should start the leading comment with a \`@fileoverview\` JSDoc tag`;
    throw Error(msg);
  }

  const content = extractStringFromComment(txt);

  const description = `
## Description
${content}
`;
  return description;
}

function extractStringFromComment(raw: string): string {
  return (
    raw
      // Remove opening /**
      .replace(/^\/\*\*+/u, '')

      // Remove closing */
      .replace(/\*+\/$/u, '')

      // Remove leading "* "
      .split('\n')
      .map((line) => line.replace(/^\s*\*\s?/u, ''))
      .join('\n')

      .replace('@fileoverview', '')
      .replaceAll('@example', '**Example:**')
      .trim()
  );
}

async function generateExamplesForRule(ruleName: string) {
  const testContent = await fs.readFile(
    path.join(import.meta.dirname, `./lib/rules/${ruleName}.test.ts`),
    { encoding: 'utf8' },
  );

  const ast = ts.createSourceFile('source.ts', testContent, ts.ScriptTarget.Latest);

  type TestCase = { name: string; code: string; output: string | undefined };
  const validTestCases: TestCase[] = [];
  const invalidTestCases: TestCase[] = [];

  function extractStringLiteralValue(node: ts.Node): string {
    if (ts.isStringLiteral(node)) return node.text;
    if (ts.isNoSubstitutionTemplateLiteral(node)) return node.text;
    throw Error('Argument passed to extractStringLiteralValue() was not a string node');
  }

  function extractOutputLiteralValue(node: ts.Node): string | undefined {
    if (ts.isArrayLiteralExpression(node)) {
      const lastElement = node.elements.at(-1);
      if (!lastElement) {
        throw Error('Test case output is an empty array');
      }
      return extractStringLiteralValue(lastElement);
    }

    if (node.kind === ts.SyntaxKind.NullKeyword) {
      return undefined;
    }

    return extractStringLiteralValue(node);
  }

  function extractTestCase(node: ts.Node): TestCase {
    if (!ts.isObjectLiteralExpression(node)) {
      throw Error('Not an object literal expression');
    }

    let name: string | undefined = undefined;
    let code: string | undefined = undefined;
    let output: string | undefined = undefined;
    for (const prop of node.properties) {
      if (!ts.isPropertyAssignment(prop)) continue;
      if (!ts.isIdentifier(prop.name)) continue;

      if (prop.name.text === 'name') {
        name = extractStringLiteralValue(prop.initializer);
      }
      if (prop.name.text === 'code') {
        code = extractStringLiteralValue(prop.initializer);
      }
      if (prop.name.text === 'output') {
        output = extractOutputLiteralValue(prop.initializer);
      }
    }

    if (typeof name === 'undefined') {
      throw Error('No name property found in test case');
    }
    if (typeof code === 'undefined') {
      throw Error('No code property found in test case');
    }

    return { name, code, output };
  }

  function extractTestCases(node: ts.Node): TestCase[] {
    if (!ts.isArrayLiteralExpression(node)) return [];

    return node.elements.map((elt) => extractTestCase(elt));
  }

  function visit(node: ts.Node) {
    ts.forEachChild(node, visit);

    if (!ts.isCallExpression(node)) return;
    if (!ts.isPropertyAccessExpression(node.expression)) return;
    if (!ts.isIdentifier(node.expression.expression)) return;
    if (!ts.isIdentifier(node.expression.name)) return;

    if (node.expression.expression.text !== 'ruleTester') return;
    if (node.expression.name.text !== 'run') return;

    const obj = node.arguments[2];
    if (!obj) return;
    if (!ts.isObjectLiteralExpression(obj)) return;

    if (obj.properties.length !== 2) return;
    const [valid, invalid] = obj.properties;
    if (!valid || !invalid) return;
    if (!ts.isPropertyAssignment(valid)) return;
    if (!ts.isPropertyAssignment(invalid)) return;
    if (!ts.isIdentifier(valid.name)) return;
    if (!ts.isIdentifier(invalid.name)) return;

    if (valid.name.escapedText.toString() !== 'valid') return;
    if (invalid.name.escapedText.toString() !== 'invalid') return;

    validTestCases.push(...extractTestCases(valid.initializer));
    invalidTestCases.push(...extractTestCases(invalid.initializer));
  }

  ts.forEachChild(ast, visit);

  function formatExample(testCase: TestCase): string {
    const output = testCase.output
      ? `
// Automatically fixed to:${testCase.output}
`
      : '';

    return `
${testCase.name}:
\`\`\`tsx

${testCase.code}
${output}\`\`\`
`;
  }

  function formatExamples(testCases: TestCase[]): string {
    const docPragma = ' #docs';
    return testCases
      .filter(({ name }) => name.includes(docPragma))
      .map(({ name, code, output }) => ({
        code,
        output,
        name: name.replace(new RegExp(`${docPragma}.*`, 'u'), ''),
      }))
      .map((testCase) => formatExample(testCase))
      .join('\n');
  }

  const validExamples = formatExamples(validTestCases);
  const invalidExamples = formatExamples(invalidTestCases);

  if (!validExamples) {
    const msg = `For rule ${ruleName}, you need to add at least one valid test case for #docs`;
    throw Error(msg);
  }
  if (!invalidExamples) {
    const msg = `For rule ${ruleName}, you need to add at least one invalid test case for #docs`;
    throw Error(msg);
  }

  const examples = `
## Cases
### Incorrect ‚ùå
${invalidExamples}

### Correct ‚úÖ
${validExamples}
`;

  return examples;
}
